{
    "collab_server" : "",
    "contents" : "---\ntitle: \"TN - SH Project - Williams\"\nauthor: 'Skye Wills'\n\n\noutput: \n  word_document: default\n---\n\n**TN soil Health project - KSSL Data, Data Analysis**\n\n##R SetUp\nThis setup 'chunk' loads needed This portion may need to be modified with updated info for your\nfile locations - alter path inside quotations, note that the backslash is used instead of the forward slash.\nThis ensures that input and output files come from the correct locations\n\n\nRequired packages\n----------------\n```{r setup, message=FALSE, warnings=FALSE}\n\nknitr::opts_chunk$set(echo = FALSE, comment = \"#\", warning = FALSE, message = FALSE, error =FALSE, tidy.opts=list(width.cutoff=60),tidy=TRUE)\n\nrm(list=ls()) #clear previous data\n \nlist.of.packages <- c(\"knitr\", \"fastmatch\", \"ggplot2\", \"Rcpp\", \"RColorBrewer\", \"lattice\", \"maps\", \"aqp\", \"soilDB\", \"tidyr\", \"tidyverse\", \"ggthemes\", \"ggmosaic\", \"RCurl\", \"ggjoy\", \"broom\", \"lme4\", \"ggjoy\", \"ggbeeswarm\", \"viridis\", 'cetcolor')\n\n \nnew.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,\"Package\"])]\nif(length(new.packages)) install.packages(new.packages)\n \nlibrary(cetcolor)\nlibrary(knitr)\nlibrary(fastmatch)\nlibrary(ggplot2)\nlibrary(Rcpp)\nlibrary(RColorBrewer)\nlibrary(lattice)\nlibrary(maps)\nlibrary(aqp)\nlibrary(soilDB)\nlibrary(stringr)\nlibrary(tidyverse)\nlibrary(tidyr)\nlibrary(ggthemes)\nlibrary(ggmosaic)\nlibrary(RCurl)\nlibrary(broom)\nlibrary(lme4)\nlibrary(ggjoy)\nlibrary(ggbeeswarm)\nlibrary(viridis)\n\n\n\n#data storge and output\n#alter path as needed\n\nsh_TN <- \"D:/Disk 2/Projects/Candiss/TN_sh\"\n\n#create subfolders to save output\nRout = paste0(sh_TN, \"/Rout/\")\nifelse(!dir.exists(file.path(Rout)), dir.create(Rout), FALSE)\n\n\n```\n \n##Inputs\n-------------\nThen relabels some columns with simpler labels. \n \n**ADD links to data** \n \n```{r data}\n#input files \n# \n\ntnsh <- read_csv('TN_kssl_data.csv')\n\nlabels <- read_csv('TN_labels.csv')\n\n\n\n```\n\n\n#### Data prep\nTN_labels file has been used to rename columns from LIMS with simple labels.\n\nUse dplyr to filter data so that only columns that we want to analyze are kept - the extras are currently labeled with X - then they are reorganized into\n \n```{r DataPrep}\n\ntn <- tnsh %>%\n  select(-(matches(\"X\"))) %>%\n   gather(Prop, Value, -c(KSSL.Project.lab, KSSL.Project.name, UserPedonID, labsampno, layerID, Comp, Cover_kind, Crop,  Mgmt, Soil, hor_desg, hor_top, hor_bot)) %>%\n  mutate(Value = as.numeric(Value), hor_top = as.numeric(hor_top), hor_bot = as.numeric(hor_bot))\n\n```\n\n\n####Bulk Density\nEvaluate bulk density to inform combining methods in dataprep phase\n```{r bd}\n \n#get data count for each type of bulk density\n#apply(tn[, grep(\"^BD\", names(tn))], 2, function(x) length(which(!is.na(x))))\ntn %>%\n  select(Comp, Prop, Value) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n  group_by(Comp, Prop)  %>%\n  summarise (N = sum(!is.na(Value))) %>%\nspread(Comp, N) \n\n\nBDo <- tn %>%\n  select(hor_desg, hor_top, hor_bot, Comp, Prop, Value) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n  ggplot(aes(Comp, Value, color = Prop)) + geom_boxplot() + geom_point()\n\nBDo\n  \ntn %>%\n  select(hor_desg, hor_top, hor_bot, Comp, Prop, Value, Cover_kind) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n  ggplot(aes(Comp, Value)) + geom_boxplot(aes(color = Prop)) + geom_point(aes(color = Prop)) + facet_wrap(~Cover_kind)\n\n# \n# very few non A horizons - taking mutate for comparable layers out\n# tn %>%\n#   select(hor_desg, hor_top, hor_bot, Comp, Prop, Value) %>%\n#   filter(str_detect(Prop, \"BD\")) %>%\n#   mutate(comp = factor(case_when(grepl(\"O\", hor_desg) ~ \"O Horizons\",\n#                           grepl(\"A\", hor_desg) ~ \"A Horizons\",\n#                           grepl(\"B\", hor_desg) ~ \"B Horizons\",\n#                           grepl(\"C\", hor_desg) ~ \"C Horizons\"), \n#                        c(\"O Horizons\", \"A Horizons\", \"B Horizons\", \"C Horizons\")    \n#   )) %>%\n#   ggplot(aes(Comp, Value)) + geom_boxplot(aes(color = Prop)) + geom_point(aes(color = Prop)) + facet_wrap(~comp)\n\n\ntn %>%\n  select(hor_desg, hor_top, hor_bot, Comp, Prop, Value) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n    ggplot(aes(hor_top, Value)) + geom_jitter(aes(color = Prop, shape = Comp)) + \n    ylab(\"Bulk Density g/cm3\") + xlab(\"Horizon Top (cm)\")\n\n\ntn %>%\n  select(hor_desg, hor_top, hor_bot, Comp, Prop, Value) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n    ggplot(aes(hor_top, Value)) + geom_point(aes(color = Prop)) + facet_grid(Comp~.) +\n    ylab(\"Bulk Density g/cm3\") + xlab(\"Horizon Top (cm)\")\n\n\n```\n\n\n\n####Db Data Prep\nInput data.  \nCreate standardized properties when multiple methods are used, such as bulk density\n  -change rank of methods to alter the way multiple methods are analyzed\n  -Currently, 2015 samples use compliant cavity because it was done on all samples (__really a core__).  For 2014, core bulk density was favored because it was done on nearly all samples\n\nAdd comparable layers to allow for \n \n```{r bdPrep}\n\nbd <- tn %>%\n  select(KSSL.Project.lab, KSSL.Project.name, UserPedonID, labsampno, layerID, Comp, Cover_kind, Crop,  Mgmt, Soil, hor_desg, hor_top, hor_bot, Prop, Value) %>%\n  filter(str_detect(Prop, \"BD\")) %>%\n  spread(Prop, Value) \n\nbd2 <- bd %>%\n  left_join(\n    tn %>% \n        select(KSSL.Project.lab, KSSL.Project.name, UserPedonID, labsampno, layerID, Comp, Cover_kind, Crop,  Mgmt, Soil, hor_desg, hor_top, hor_bot, Prop, Value)%>% \n      filter(Prop %in% c(\"Clay\", \"Tot_C\", \"CaCarb\")) %>%  spread(Prop, Value))\n    \n\n#Order of bulk density selection - change order if desired\nbd_1 <- \"BD_Clod_13\"\nbd_2 <- \"BD_3inCore\"\nbd_4 <- \"BD_compcav\"\nbd_3 <- \"BD_4inCore\"\n\n\n#create new data element that combines all bulk density methods'\nbd2 <- bd2 %>%\n  mutate(BD = ifelse(!is.na(get(bd_1)), get(bd_1),\n    ifelse(!is.na(get(bd_2)), get(bd_2), \n      ifelse(!is.na(get(bd_3)),get(bd_3),           \n        ifelse(!is.na(get(bd_4)), get(bd_4),             \n           NA))))\n    )\n  \n\n\n#if you need to seperate by year\n# bd2$BD <- ifelse(bd2$Date == \"2015\", \n#                               as.numeric(\n#   ifelse(!is.na(bd2[,bd_1]), bd2[,bd_1],\n#     ifelse(!is.na(bd2[,bd_2]), bd2[,bd_2],\n#     ifelse(!is.na(bd2[,bd_3]), bd2[,bd_3],           \n#     ifelse(!is.na(bd2[,bd_4]), bd2[,bd_4],             \n#            NA\n#   ))))), \n#       as.numeric(\n#       ifelse(!is.na(bd2[,bd_1]), bd2[,bd_1],\n#         ifelse(!is.na(bd2[,bd_2]), bd2[,bd_2],\n#         ifelse(!is.na(bd2[,bd_3]), bd2[,bd_3],           \n#         ifelse(!is.na(bd2[,bd_4]), bd2[,bd_4],             \n#                NA\n#       )))))\n# )\n\n\n#pedon bd avg\npedBD <- bd2 %>%\n  group_by(UserPedonID) %>%\n  summarise(ped_avg = mean(BD, na.rm=T))\n\n# add ped avg bd\nbd2 <- left_join(bd2, pedBD) %>%\n  mutate(BulkDensity = as.numeric(ifelse(is.na(BD), ped_avg, BD) ))\n \n#add source description Comp\nbd2 <- bd2 %>%\n  mutate(bd_source =ifelse(!is.na(get(bd_1)), bd_1,\n    ifelse(!is.na(get(bd_2)), bd_2,\n      ifelse(!is.na(get(bd_3)),bd_3,           \n        ifelse(!is.na(get(bd_4)), bd_4,             \n     \"ped_avg\"))))\n  )\n \ntable(bd2$bd_source)\nsummary(bd2$BulkDensity)\n\n\n\nggplot(bd2, aes(y = BulkDensity, x = Comp)) + geom_boxplot(aes(fill = bd_source))\n\nggplot(bd2, aes(y = BulkDensity, x = bd_source)) + geom_jitter(aes(color = Clay, shape = Comp))\n                                                               \nggplot(bd2, aes(y = BulkDensity, x = bd_source)) + geom_jitter(aes(color = Tot_C), size = 8) + facet_grid(Comp~Soil) +     theme(axis.text.x=element_text(angle=-45, hjust = .1)) + scale_colour_gradient2(low = \"green\", mid = \"grey\", high = \"blue\", midpoint = 2)\n\nggplot(bd2, aes(y = BulkDensity, x= Clay))+ geom_jitter(aes(color = Tot_C), size = 8) +    theme(axis.text.x=element_text(angle=-45, hjust = .1)) + scale_colour_gradient2(low = \"green\", mid = \"grey\", high = \"blue\", midpoint = 1.5)\n\nggplot(bd2, aes(y = BulkDensity, x= Tot_C))+ geom_jitter(aes(color = Clay), size = 8) +    theme(axis.text.x=element_text(angle=-45, hjust = .1)) + scale_colour_gradient2(low = \"red\", mid = \"grey\", high = \"green\", midpoint = 22)\n\n#change na's to zero for Calcium carbonate\nbd2$CaCarb[is.na(bd2$CaCarb)]<- 0\n \nsummary(bd2$CaCarb)\n\n#calculate SOC and change anything less than 0 to 0 \nbd2$CALC_SOC <- bd2$Tot_C - (bd2$CaCarb*0.12)\n\nbd2$CALC_SOC[bd2$CALC_SOC<0] <- 0\n\nsummary(bd2$CALC_SOC)\n\n\n#join back to original data\n\nwd <- tn %>%\n  mutate_if(is.factor, as.character) %>%\n  mutate_if(is.integer, as.numeric) %>%\n  bind_rows(bd2 %>%\n              select(KSSL.Project.lab, KSSL.Project.name, UserPedonID, labsampno, layerID, Comp, Cover_kind, Crop,  Mgmt, Soil, hor_desg, hor_top, hor_bot, BulkDensity, CALC_SOC) %>%\n              mutate_if(is.factor, as.character) %>%\n              mutate_if(is.integer, as.numeric) %>%\n              gather(Prop, Value, -c(KSSL.Project.lab, KSSL.Project.name, UserPedonID, labsampno, layerID, Comp, Cover_kind, Crop,  Mgmt, Soil, hor_desg, hor_top, hor_bot))\n  \n  )\n\n \n```\n \nRemoved this section - didn't include coarse fragments\n<!-- ##Pedon stocks/totals -->\n\n<!-- ```{r stocks} -->\n<!-- #filter to remove replicates -->\n<!-- Wd <- wd #past analysis filtered at this stage -->\n\n<!-- Wd %>% -->\n<!--      filter(Prop %in% c('CALC_SOC', 'BulkDensity'))%>% -->\n<!--      spread(Prop, Value) -->\n\n<!-- #simplify variables and calculate SOC density for each sample -->\n<!-- W_ped <- Wd %>%  -->\n<!--      filter(Prop %in% c('CALC_SOC', 'Tot_N', 'Tot_C', 'CF_labvol', 'BulkDensity')) %>% -->\n<!--      spread(Prop, Value) %>% -->\n<!--     mutate(SOC = ifelse(CALC_SOC<0, 0, CALC_SOC), -->\n<!--            bd = BulkDensity, TN=Tot_N,  -->\n<!--            TOP = hor_top, BOT = hor_bot, -->\n<!--            CF = ifelse(CF_labvol==0,0,CF_labvol/100)) %>%  -->\n<!--     mutate(thick = BOT - TOP, SOCden = SOC*bd*(1 - CF), TNden = TN*bd*(1 - CF)) %>% -->\n<!--     mutate(d5  = ifelse(BOT <=5, thick, ifelse(TOP<5, 5-TOP,0 )), -->\n<!--            d30 = ifelse(BOT <=30, thick, ifelse(TOP<30, 30-TOP,0 ))) %>% -->\n\n<!--   #check values for on pedon with NA values   -->\n<!--     # filter(Date==\"2014\" & Comp==\"GR1\" & Pedon ==\"A\" & Soil_abbrev == \"O\") %>% -->\n<!--     #   select(UserPedonID, Date, Comp, Pedon, Veg, Till, MGMT, Soil_abbrev, TOP, BOT, SOC, BD, bd, CF, SOCden, TNden, d5, d30, d50, d100) %>% -->\n\n<!--     select(UserPedonID, Date, Comp, Pedon, Veg, Till, MGMT, Soil_abbrev, SOCden, TNden, d5, d30, d50, d100) %>% -->\n<!--     group_by(UserPedonID, Date, Comp, Pedon, Veg, Till, MGMT, Soil_abbrev) %>% -->\n<!--     summarise(SOCstock5 = sum(SOCden*d5, na.rm = T), -->\n<!--                   SOCstock30 = sum(SOCden*d30, na.rm = T), -->\n<!--                   SOCstock50 = sum(SOCden*d50, na.rm = T), -->\n<!--                   TNstock5 = sum(TNden*d5, na.rm = T), -->\n<!--                   TNstock30 = sum(TNden*d30, na.rm = T), -->\n<!--                   TNstock50 = sum(TNden*d50, na.rm = T) -->\n<!--         ) -->\n\n\n<!-- ```  -->\n\n\n###Exploratory plots\n<!-- #### stocks -->\n<!-- ```{r graphs} -->\n<!-- names(W_ped) #check names for gather function (list labels - everything else goes into the var and stock columns) -->\n\n<!-- # columns that will be combined in order you want them displayed -->\n<!-- col <- c(\"SOCstock5\",  \"SOCstock30\", \"SOCstock50\", \"TNstock5\", \"TNstock30\",  \"TNstock50\" ) -->\n\n\n<!--   W_ped %>%  -->\n<!--   gather(key = var , value = stock, -c(UserPedonID, Date, Comp, Pedon, Veg, Till, MGMT, Soil_abbrev))%>% -->\n<!--   ggplot(aes(y = stock, x = Soil_abbrev)) + geom_boxplot(aes(fill = MGMT), alpha = .5)  + facet_wrap(~var, nrow = 4, scales = \"free_y\") -->\n\n<!--     #free_y allows he y axis to change between plots (remove to better compare between plots) -->\n\n\n\n<!-- ``` -->\n\n\n\n#### Surface Properties\n\n\n```{r graphs2 }\nWd <-wd #recreate skipped steps\n\nProperties <- c('WaterSol_P', 'Mehlich3_P', ' Tot_P', 'NewZ_P') #list of properties that will be graphed\n\nggplot(Wd %>% filter(Prop %in% Properties & hor_top == 0), aes(y = Value, x = Soil)) + geom_boxplot(aes(fill = Comp), alpha = .5) +  facet_wrap(~Prop, ncol=5, scales = \"free_y\") +\n  theme(legend.position=\"top\",  axis.text.x=element_text(angle=-45, hjust = -.01), strip.text.y=element_text(size=4)) +\n  ggtitle(\"Surface Sample\") # need to add labeller = nameProp\n\nProperties2 <- c('AggStab', 'Bgluc',  'Pom_C')\n\nggplot(Wd %>% filter(Prop %in% Properties2 & hor_top == 0), aes(y = Value, x = Soil)) + geom_boxplot(aes(fill = Comp), alpha = .5)   +   facet_wrap(~Prop, ncol=3, scales = \"free_y\") +\n  theme(legend.position=\"top\",  axis.text.x=element_text(angle=-45, hjust = -.01), strip.text.y=element_text(size=4)) +\n  ggtitle(\"Surface Sample\") # need to add labeller = nameProp\n\n\nProperties3 <- c('Tot_N', 'Pom_N','BulkDensity', 'ph_h20', 'CEC_ph7')\n\nggplot(Wd %>% filter(Prop %in% Properties3 & hor_top == 0), aes(y = Value, x = Soil)) + geom_boxplot(aes(fill = Comp), alpha = .5)   +   facet_wrap(~Prop, ncol=5, scales = \"free_y\") +\n  theme(legend.position=\"top\",  axis.text.x=element_text(angle=-45, hjust = -.01), strip.text.y=element_text(size=4)) +\n  ggtitle(\"Surface Sample\") # need to add labeller = nameProp\n\n\n```\n\n##Exploratory Plots\nIndividual \n```{r joyplots}\n\n\n\nlev <- as.factor(Wd$Prop)\n\n\n#pdf(file = 'explore_plots.pdf')\nfor(i in unique(lev)){\nprint(i)\n b <- ggplot(Wd %>% filter(Prop == i) , aes(y = Value, x = Comp)) + \n  geom_boxplot(aes(fill = Comp), alpha = .5) +\n  theme(legend.position=\"none\")  +  ylab(paste(i)) + xlab(\" \") +\n   ggtitle(paste0(i, \" for all Samples\")) \nprint(b)\n\nj <- Wd%>% filter(Prop == i )%>%\n  ggplot(aes(x=Value, y = Comp, color = hor_top)) +  \n  geom_quasirandom(alpha=0.82, groupOnX=FALSE, size = 10) + \n  theme_joy() +\n    scale_color_gradient(name = \"Top\") +\n  theme(plot.caption=element_text(hjust=0,size=10),\n        axis.title=element_text(size=12),\n        plot.title=element_text(size=24))+\n  labs(x= i ,y=\"\",caption=\"@wills_skye\")\n\nprint(j)\n\n}\n#dev.off()\n\n#joy plot example\n# https://stackoverflow.com/questions/45384281/ggjoy-facet-with-ggtree\n\n\n\n```\n\n\n\n##Summary by comparable\n```{r summary, message=FALSE, warnings=FALSE}\n\n\nProperties <- c('WaterSol_P', 'Mehlich3_P', 'Tot_P', 'NewZ_P', 'AggStab', 'Bgluc',  'Pom_C', 'CALC_SOC', 'Tot_N', 'Pom_N','BulkDensity', 'ph_h20', 'CEC_ph7')\n\n\nComp.SOIL <- as.data.frame(Wd %>% \n  filter(Prop %in% Properties) %>%\n  select(Comp, Soil, Prop, Value, hor_top, hor_bot) %>%\n  mutate(thick = hor_bot - hor_top) %>%\n   group_by(Comp, Soil, Prop)%>%\n   summarise(N= sum(!is.na(Value)),\n             wt.mean = weighted.mean(x= Value, w = thick, na.rm=TRUE),\n             min = min(Value, na.rm=T), \n             max = max(Value, na.rm=T)))\n    \nComp <- as.data.frame(Wd %>% \n  filter(Prop %in% Properties) %>%\n  select(Comp, Soil, Prop, Value, hor_top, hor_bot) %>%\n  mutate(thick = hor_bot - hor_top) %>%\n   group_by(Comp, Prop)%>%\n   summarise(N= sum(!is.na(Value)),\n             w.mean = weighted.mean(x= Value, w = thick, na.rm=TRUE),\n             min = min(Value, na.rm=T), \n             max = max(Value, na.rm=T)))\n    \nComp.SOIL.surf <- as.data.frame(Wd %>% \n  filter(Prop %in% Properties & hor_top ==0) %>%\n  select(Comp, Soil, Prop, Value, hor_top, hor_bot) %>%\n  mutate(thick = hor_bot - hor_top) %>%\n   group_by(Comp, Soil, Prop)%>%\n   summarise(N= sum(!is.na(Value)),\n             wt.mean = weighted.mean(x= Value, w = thick, na.rm=TRUE),\n             min = min(Value, na.rm=T), \n             max = max(Value, na.rm=T)))\n    \nComp.surf <- as.data.frame(Wd %>% \n  filter(Prop %in% Properties& hor_top ==0) %>%\n  select(Comp, Soil, Prop, Value, hor_top, hor_bot) %>%\n  mutate(thick = hor_bot - hor_top) %>%\n   group_by(Comp, Prop)%>%\n   summarise(N= sum(!is.na(Value)),\n             w.mean = weighted.mean(x= Value, w = thick, na.rm=TRUE),\n             min = min(Value, na.rm=T), \n             max = max(Value, na.rm=T)))\n\nwrite_csv(Comp.SOIL, file.path(Rout, \"Comp_soil.csv\"))\nwrite_csv(Comp, file.path(Rout, \"Comp.csv\"))\nwrite_csv(Comp.SOIL.surf, file.path(Rout, \"Comp_soil_surf.csv\"))\nwrite_csv(Comp.surf, file.path(Rout, \"Comp_surf.csv\"))\n\n```\n\n#Test for diff\n###by Surface, A horizons, and then B horizons\n```{r test}\n\nProperties <- c('WaterSol_P', 'Mehlich3_P', 'Tot_P', 'NewZ_P', 'AggStab', 'Bgluc',  'Pom_C', 'CALC_SOC', 'Tot_N', 'Pom_N','BulkDensity', 'pH_H20', 'CEC_ph7')\n\nMsurf <- Wd %>% \n  filter(Prop %in% Properties & hor_top == 0)\n\nsurf.n <- Msurf %>%\n   group_by(Prop)%>%\n  nest()\n\n\n#function for glm model \nfit_mod <- function(data){\n    mod <- lm(Value ~ Comp, random=~1|Comp, data = data)\n    return(anova(mod))\n  }\n\n#check that output is appropriate\n# \n fit_mod(surf.n$data[[1]])\n# #\n surf.n <- surf.n %>%\n   mutate(mod = purrr::map(data, fit_mod))\n# #\n#surf.n$mod[[1]]\n# #\n#   broom::glance(surf.n$mod[[1]])\n#   broom::tidy(surf.n$mod[[1]])\n  \nsurf.n <- surf.n %>%\n                 dplyr::mutate(tidy = purrr::map(mod, broom::tidy),\n                               n = purrr::map(data, nrow) %>% simplify())\n\nsurf.n\n  \nsurf.m <- surf.n %>%\n                   tidyr::unnest(tidy) \n                  # dplyr::select(-(std.error:p.value)) %>%\n                  # tidyr::spread(term, estimate)\n                  # \nsurf.m\n\n\nwrite_csv(surf.m, file.path(Rout,\"Test.surface.csv\"))\n\n\n# A.M <- Wd %>% \n#   filter(Prop %in% Properties) %>%\n#   mutate(Comp = factor(Comp, levels = c('CT-C/S', 'RT-C/S', 'Grass'))) %>%\n#   filter(Soil == \"Leen\" & comp %in% c(\"A Horizons\", \"B Horizons\")) %>%\n#   group_by(Comp, Comp, Prop, comp) %>%\n#   summarise(Value = mean(Value, na.rm=TRUE))\n# \n\n# \n# A.lm.mc <- A.M %>%  filter(comp %in% c(\"A Horizons\"))%>%\n#    group_by(Prop)%>%\n#   nest()\n# \n# #function for glm model \n# fit_mod <- function(data){\n#     mod <- lm(Value ~ Comp, random=~1|Comp, data = data)\n#     return(anova(mod))\n# }\n# \n# \n# #check that output is appropriate\n# \n# fit_mod(A.lm.mc$data[[1]])\n#  \n# A.lm.mc <- A.lm.mc %>%\n#    mutate(mod = purrr::map(data, fit_mod))\n# \n# A.lm.mc$mod[[1]]\n#  \n#    # broom::glance(surf.n$mod[[1]])\n#    # broom::tidy(surf.n$mod[[1]])\n# \n# \n# comp.A <- A.lm.mc %>%\n#                  dplyr::mutate(tidy = purrr::map(mod, broom::tidy),\n#                                n = purrr::map(data, nrow) %>% simplify())\n# \n# comp.A\n#   \n# comp.A <- comp.A %>%\n#                    tidyr::unnest(tidy) \n#                   # dplyr::select(-(std.error:p.value)) %>%\n#                   # tidyr::spread(term, estimate)\n#                   # \n# comp.A\n# \n# PropertiesB <- c('WaterSol_P', 'Mehlich3_P', 'Tot_P', 'NewZ_P', 'Pom_C', 'CALC_SOC', 'Tot_N', 'Pom_N','BulkDensity', 'pH_H20', 'CEC_ph7')\n# \n# B.M <- Wd %>% \n#   filter(Prop %in% PropertiesB) %>%\n#   mutate(Comp = factor(Comp, levels = c('CT-C/S', 'RT-C/S', 'Grass'))) %>%\n#   filter(Soil == \"Leen\" & comp %in% c(\"A Horizons\", \"B Horizons\")) %>%\n#   group_by(Comp, Comp, Prop, comp) %>%\n#   summarise(Value = mean(Value, na.rm=TRUE))\n# \n# \n# B.lm.mc <- B.M %>%  filter(comp %in% c(\"B Horizons\"))%>%\n#    group_by(Prop)%>%\n#   nest()\n# \n# #function for glm model \n# fit_mod <- function(data){\n#     mod <- lm(Value ~ Comp, random=~1|Comp, data = data)\n#     return(anova(mod))\n# }\n# \n# \n# #check that output is appropriate\n# \n# fit_mod(B.lm.mc$data[[1]])\n#  \n# B.lm.mc <- B.lm.mc %>%\n#    mutate(mod = purrr::map(data, fit_mod))\n# \n# B.lm.mc$mod[[1]]\n#  \n#    # broom::glance(surf.n$mod[[1]])\n#    # broom::tidy(surf.n$mod[[1]])\n# \n# \n# comp.B <- B.lm.mc %>%\n#                  dplyr::mutate(tidy = purrr::map(mod, broom::tidy),\n#                                n = purrr::map(data, nrow) %>% simplify())\n# \n# comp.B\n#   \n# comp.B <- comp.B %>%\n#                    tidyr::unnest(tidy) \n#                   # dplyr::select(-(std.error:p.value)) %>%\n#                   # tidyr::spread(term, estimate)\n#                   # \n# comp.B\n\n\n   \n```\n\n##Alternate tests\n###Surface Sample Tests\n####using mixed models\n\n<!-- ``` {r mixedmodel} -->\n\n<!-- library(lme4) -->\n\n<!-- Msurf <- Wd %>%  -->\n<!--   filter(Prop %in% Properties) %>% -->\n<!--   select(Comp, Comp, Soil, comp, Prop, Value, hor_top) %>% -->\n<!--   mutate(Comp = factor(Comp, levels = c('CT-C/S', 'RT-C/S', 'Grass'))) %>% -->\n<!--   filter(Soil == \"Leen\" & hor_top == 0) -->\n\n\n<!-- lev <- as.factor(Msurf$Prop) -->\n\n<!-- for(i in unique(lev)){ -->\n<!-- print(i) -->\n<!-- Msurf_i <- Msurf[Msurf$Prop %in% i,]    -->\n<!-- Comp <- with(Msurf_i, lmer(Value~Comp+ (1|Comp:Comp))) -->\n<!-- Comp<- with(Msurf_i, lmer(Value~(1|Mgmt:Comp))) -->\n<!-- a <- anova(MGMT, Comp) -->\n<!-- print(a) -->\n\n\n<!-- model = lmer(Value ~ Mgmt + (1|Mgmt:Comp), -->\n<!--               data=Msurf_i, -->\n<!--               REML=TRUE) -->\n\n<!--  anova(model) -->\n\n\n<!--  difflsmeans(model, -->\n<!--              test.effs=\"Mgmt\") -->\n\n\n<!--  posthoc = glht(model, -->\n\n<!--                linfct = mcp(Mgmt=\"Tukey\")) -->\n\n<!--  mcs = summary(posthoc, -->\n\n<!--               test=adjusted(\"single-step\")) -->\n\n<!--  mcs -->\n\n\n<!-- } -->\n\n\n\n\n<!-- } -->\n\n\n<!-- ``` -->\n\n<!-- ##test for multiple comparisons -->\n<!-- test for sig diff -->\n\n\n<!-- ```{r compare} -->\n\n\n<!-- #from https://rcompanion.org/rcompanion/d_07.html -->\n\n<!-- if(!require(nlme)){install.packages(\"nlme\")} -->\n<!--  if(!require(multcomp)){install.packages(\"multcomp\")} -->\n<!--  if(!require(multcompView)){install.packages(\"multcompView\")} -->\n<!--  if(!require(lsmeans)){install.packages(\"lsmeans\")} -->\n<!--  if(!require(lme4)){install.packages(\"lme4\")} -->\n<!--  if(!require(lmerTest)){install.packages(\"lmerTest\")} -->\n<!--  if(!require(TukeyC)){install.packages(\"TukeyC\")} -->\n\n<!-- library(nlme) -->\n<!-- library(multcomp) -->\n\n<!--  library(multcompView) -->\n<!--  library(lsmeans) -->\n\n<!-- library(lme4) -->\n<!--  library(lmerTest) -->\n\n<!--  library(TukeyC) -->\n\n<!-- # change inputs to Msurf to look at different layers or properties -->\n\n<!-- lev <- as.factor(Msurf$Prop) -->\n\n<!-- for(i in unique(lev)){ -->\n<!-- print(i) -->\n<!-- Msurf_i <- Msurf[Msurf$Prop %in% i,]  -->\n\n<!-- #simple boxplot for sanity check -->\n<!-- ggplot(Msurf_i, aes(y = Value, x= MGMT)) + geom_boxplot(aes(fill = MGMT))  -->\n\n<!-- a <- aov(Value ~ Mgmt + Error(Mgmt:Comp), data=Msurf_i) -->\n<!-- summary(a) -->\n\n\n<!--  model = lme(Value ~ Mgmt, random=~1|Comp, #Linear mixed-effects model (allows for netsted random effects) -->\n<!--              data=Msurf_i,  -->\n<!--              method=\"REML\") -->\n\n<!--  al <- anova.lme(model,  -->\n<!--            type=\"sequential\",  -->\n<!--            adjustSigma = FALSE) -->\n<!-- print(al) -->\n\n\n<!--  posthoc = glht(model, -->\n<!--                 linfct = mcp(Mgmt=\"Tukey\"))  # compare all means (not adjustment of multiple comparisons) -->\n\n<!--  mcs = summary(posthoc, -->\n<!--                test=adjusted(\"single-step\")) -->\n\n<!--  print(mcs) -->\n\n<!--  m <- lm(Value ~ Mgmt, random=~1|Comp, #Linear mixed-effects model (allows for netsted random effects) -->\n<!--              data=Msurf_i) -->\n\n<!--  anova(m) -->\n\n<!--  leastsquare = lsmeans(m,  -->\n<!--                        pairwise ~ Mgmt,  -->\n<!--                        adjust=\"tukey\")       ###  Tukey-adjusted comparisons -->\n\n<!-- print(leastsquare) -->\n\n<!-- cld(leastsquare, -->\n<!--      alpha=0.05, -->\n<!--      Letters=letters,      ### Use lower-case letters for .group -->\n<!--      adjust=\"tukey\")       ### Tukey-adjusted comparisons -->\n\n\n<!-- model.fixed = gls(Value ~ Mgmt,  -->\n<!--                    data=Msurf_i,  -->\n<!--                    method=\"REML\") -->\n\n<!-- a2 <-  anova(model,  -->\n<!--        model.fixed) -->\n\n<!-- print(a2)  -->\n\n<!-- hist(residuals(model),  -->\n<!--       col=\"darkgray\") -->\n\n<!-- plot(fitted(model),  -->\n<!--       residuals(model))  -->\n\n<!-- fit = aov(Value ~ Mgmt + Error(Comp), data=Msurf_i) -->\n<!--  summary(fit) -->\n\n\n<!--  # tuk = TukeyC(Msurf_i, -->\n<!--  #              model = 'Value ~ Mgmt + Error(Comp)', -->\n<!--  #              error = 'Comp', -->\n<!--  #              which = 'Mgmt', -->\n<!--  #              fl1=1, -->\n<!--  #              sig.level = 0.05) -->\n<!--  #  -->\n<!--  # summary(tuk) -->\n\n\n<!-- } -->\n<!-- ``` -->\n\n\n\n\n\n\n\n\n<!-- ``` -->\n\n\n\n<!-- ##Depth plots -->\n\n<!-- # ```{r depthplotPrep, eval=T} -->\n<!-- #  -->\n<!-- # require(aqp) -->\n<!-- #  -->\n<!-- # # select soil and properties of interest -->\n<!-- #  -->\n<!-- #  -->\n<!-- # wfbc <- Wd %>%  -->\n<!-- #     #select(Soil, MGMT, hor_top, hor_bot, Prop, Value)%>% -->\n<!-- #     filter(Soil == \"Leen\" & Prop %in% c('CALC_SOC', 'AggStab', 'BulkDensity', 'WaterSol_P', 'Mehlich3_P', 'Tot_P', 'NewZ_P', 'ph_h20')) %>%  -->\n<!-- #  spread(Prop, Value)  -->\n<!-- #    -->\n<!-- #  -->\n<!-- #  -->\n<!-- # #use aqp package to treat groups of samples as pedons with locations and depths -->\n<!-- # # promote to soil profile  -->\n<!-- #  -->\n<!-- #  -->\n<!-- # depths(wfbc) <- UserPedonID  ~ hor_top + hor_bot -->\n<!-- #  -->\n<!-- # # move some site-level data to site slot -->\n<!-- # site(wfbc) <- ~ MGMT -->\n<!-- #  -->\n<!-- #   CALC_SOC + AggStab + BulkDensity + WaterSol_P + Mehlich3_P + Tot_P + NewZ_P + ph_h20 -->\n<!-- #  -->\n<!-- # # slice horizon samples into individual 1cm depth slices for calculation -->\n<!-- # # depth-wise quantiles, by LU -->\n<!-- # #because all pedons had a 0 -5cm sample collect and other depths were allowed to flucuate, this creates some artifacts -->\n<!-- #  -->\n<!-- # a <- slab(wfbc, MGMT ~ Value) -->\n<!-- # b <- slab(wfbc, Prop ~Value) -->\n<!-- #  -->\n<!-- # D <- cbind(a,b[2]) -->\n<!-- #  -->\n<!-- #  -->\n<!-- # # custom colors -->\n<!-- # tps <- list(superpose.line=list(col=c( 'DarkGreen', \"LightGreen\",'DarkRed'), lwd=3)) -->\n<!-- #  -->\n<!-- #  -->\n<!-- # devAskNewPage(ask=T) -->\n<!-- # xyplot(top ~ p.q50 | Prop, groups=MGMT, data=D, ylab=list('Depth (cm)', cex= 1.5), -->\n<!-- #                 xlab=list(' \\n Median (line) bounded by 25th and 75th percentiles (shaded)', cex = 1), -->\n<!-- #                 lower=a$p.q25, upper=a$p.q75, ylim=c(100,0), -->\n<!-- #                 panel=panel.depth_function, alpha=0.25, sync.colors=TRUE, -->\n<!-- #                 prepanel=prepanel.depth_function, -->\n<!-- #                 strip=strip.custom(bg=grey(0.85)), -->\n<!-- #                 scales=list(x=list(alternating=1)), -->\n<!-- #                subset=variable == 'CALC_SOC', -->\n<!-- #                 auto.key=list(columns=3,   -->\n<!-- #                               space = \"top\", just = .005,  lines=TRUE, points=FALSE, cex=.6), -->\n<!-- #                 xlim=c(0,10) -->\n<!-- # ) -->\n<!-- # #reset page ask -->\n<!-- #  devAskNewPage(ask=NULL) -->\n<!-- #  -->\n<!-- # ``` -->\n",
    "created" : 1516805937580.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "170548088",
    "id" : "10466FF7",
    "lastKnownWriteTime" : 1516831953,
    "last_content_update" : 1516831953489,
    "path" : "D:/Disk 2/Projects/Candiss/TN_sh/TN_Rmarkdown1.Rmd",
    "project_path" : "TN_Rmarkdown1.Rmd",
    "properties" : {
        "last_setup_crc32" : ""
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}