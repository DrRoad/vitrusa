```{r NASIS query and report inventory}

get_NASIS_db <- function() {
  # must have RODBC installed
  if(!requireNamespace('RODBC'))
    stop('please install the `RODBC` package', call.=FALSE)
  
  q <- "SELECT p.uprojectid, p.projectname, a.areasymbol, lmu.lmapunitiid AS mukey, lmu.musym, mu.nationalmusym, muacres
  
  FROM project p

  INNER JOIN projectmapunit pmu ON pmu.projectiidref = p.projectiid
  INNER JOIN mapunit mu ON mu.muiid = pmu.muiidref

  LEFT OUTER JOIN lmapunit lmu ON lmu.muiidref = mu.muiid
  LEFT OUTER JOIN legend l ON l.liid = lmu.liidref
  INNER JOIN area a ON a.areaiid = p.mlrassoareaiidref

  WHERE a.areasymbol LIKE '11-%' AND p.projectname LIKE 'SDJR%' AND p.uprojectid LIKE '2016%'
      AND mu.mutype != 1

  ORDER BY p.projectname, a.areasymbol
  ;"
  
  # setup connection local NASIS
  channel <- RODBC::odbcDriverConnect(connection="DSN=nasis_local;UID=NasisSqlRO;PWD=nasisRe@d0n1y")
  
  # exec query
  d <- RODBC::sqlQuery(channel, q, stringsAsFactors=FALSE)

  # close connection
  RODBC::odbcClose(channel)
  
  # done
  return(d)
}


get_reports_NASIS_db <- function() {
  # must have RODBC installed
  if(!requireNamespace('RODBC'))
    stop('please install the `RODBC` package', call.=FALSE)
  
  q <- "SELECT rptiid, rptname, grpname, nasissitename
  
  FROM report
  
  INNER JOIN nasisgroup ng ON ng.grpiid = report.grpiidref
  INNER JOIN nasissite ns ON ns.nasissiteiid = ng.nasissiteiidref;"
  
  # setup connection local NASIS
  channel <- RODBC::odbcDriverConnect(connection="DSN=nasis_local;UID=NasisSqlRO;PWD=nasisRe@d0n1y")
  
  # exec query
  d <- RODBC::sqlQuery(channel, q, stringsAsFactors=FALSE)
  
  # close connection
  RODBC::odbcClose(channel)
  
  # done
  return(d)
}

```

```{r Steve Campbell examples}

# Dom Component NASIS report. The yellow highlighted area is the dominant component part of the script. 

PARAMETER area2 ELEMENT area.areasymbol PROMPT 'Survey Symbol for wildcards use % '.

BASE TABLE component.

EXEC SQL
SELECT DISTINCT areasymbol, lmapunitiid/1 AS mukey, musym, dmuiid, muiid, muname, farmlndcl, coiid/1 AS coiid, component.compname AS tc, comppct_r, majcompflag 
FROM REAL area_type
INNER JOIN        REAL area BY default AND areasymbol LIKE area2 AND areatypename = 'non-mlra soil survey area'
INNER JOIN        REAL legend BY default AND legendsuituse = 'current wherever mapped'
INNER JOIN        REAL lmapunit BY default
INNER JOIN  REAL mapunit BY default AND mustatus = 'correlated'
INNER JOIN  REAL correlation BY default
INNER JOIN  REAL datamapunit BY default AND repdmu = 1
INNER JOIN  REAL component BY default 
AND component.coiid =
(SELECT TOP 1 c1.coiid FROM component AS c1 
INNER JOIN datamapunit AS d1 ON  d1.dmuiid=c1.dmuiidref
INNER JOIN correlation AS cor1 ON cor1.dmuiidref=d1.dmuiid AND repdmu =1
INNER JOIN mapunit AS c ON c.muiid=cor1.muiidref AND c.muiid=mapunit.muiid ORDER BY c1.comppct_r DESC, c1.coiid);.

# component_wtavg_pH_SDA_query - This query calculates the weighted average pH in the 0-50 cm depth range for major components
-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r INTO #table1

FROM legend

INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey 
-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r
-- Calculate horizon thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2
FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate pH multiplied by horizon thickness

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4
FROM #table3

GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate weighted average pH for components

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC



# component_wtavg_pH_SDA_query - This query calculates the weighted average pH in the 0-50 cm depth range for major components

-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r

INTO #table1

FROM legend

INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey 
-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r
-- Calculate horizon thicknesses


SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2


FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate pH multiplied by horizon thickness


SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4

FROM #table3
GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r
ORDER BY areasymbol, musym, comppct_r DESC
-- Calculate weighted average pH for components

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC



# sda_sql_query_for_taxonomy - SDA SQL query for taxonomy- Note will not get result for consociations of miscellaneous areas such as water -Rob Vaughan with help from Steve Campbell 

SELECT
legend.areasymbol, legend.lkey, mapunit.muname, mapunit.mukey, component.cokey, component.comppct_r, component.compname, component.compkind, component.taxclname, component.taxorder, component.taxsuborder, component.taxgrtgroup, component.taxsubgrp, component.taxpartsize, component.taxpartsizemod, component.taxtempcl, component.taxmoistscl, component.taxtempregime, component.soiltaxedition

FROM legend
INNER JOIN mapunit ON legend.lkey = mapunit.lkey  
LEFT OUTER JOIN component ON mapunit.mukey = component.mukey  
  
WHERE legend.areasymbol LIKE 'WY043%' AND 
component.cokey = (SELECT TOP 1 component.cokey FROM component.mukey = mapunit.mukey AND component.taxorder is not null ORDER BY component.comppct_r DESC)
ORDER BY component.comppct_r DESC)

ORDER BY legend.areasymbol, legend.lkey, mapunit.mukey, component.cokey



# mapunit_wtavg_pH_SDA_query -- This query calculates the weighted average pH in the 0-50 cm depth range for major components aggregated to the mapunit.

-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r

INTO #table1

FROM legend
INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey

-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r

-- Calculate horizon thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2
FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r

-- Calculate pH multiplied by horizon thickness

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r

-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4
FROM #table3

GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate weighted average pH for component

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

INTO #table5
FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate sums to use in mapunit weighted average pH calculation.

SELECT areasymbol, areaname, musym, muname, mukey, sum(comppct_r) AS sum_comppct, sum(comppct_r * pH_wtavg_0_50) AS sum_comppct_x_pH

INTO #table6
FROM #table5

GROUP BY areasymbol, areaname, musym, muname, mukey

ORDER BY areasymbol, musym

-- Calculate mapunit weighted average pH

SELECT areasymbol, areaname, musym, muname, mukey, CAST(sum_comppct_x_pH / sum_comppct AS Decimal(4,1)) AS pH_wtavg_0_50_mu

FROM #table6

ORDER BY areasymbol, musym
```

```{r correlation example}
EXEC SQL SELECT
projectiid/1 AS projectiid,
uprojectid,
projectname,
m.muname,
m2.muname,
m.nationalmusym,
l.liid/1 AS liid,
a.areasymbol,
lm.musym,
lm.lmapunitiid/1 as mukey,
CODELABEL(lm.mustatus) as mustatus,
lm.muacres,
dmudesc

FROM project AS p
INNER JOIN REAL projectmapunit AS pm ON pm.projectiidref = p.projectiid
INNER JOIN REAL mapunit AS m ON m.muiid = pm.muiidref
INNER JOIN REAL correlation AS c ON c.muiidref = m.muiid
INNER JOIN REAL datamapunit AS dm ON dm.dmuiid = c.dmuiidref
INNER JOIN REAL correlation AS c2 on c2.dmuiidref = dm.dmuiid
INNER JOIN REAL mapunit AS m2 on m2.muiid = c2.muiidref

INNER JOIN REAL lmapunit AS lm ON lm.muiidref = m.muiid
INNER JOIN REAL legend AS l ON l.liid = lm.liidref
INNER JOIN REAL area AS a ON a.areaiid = l.areaiidref;.

PAGE WIDTH UNLIMITED LENGTH UNLIMITED.

TEMPLATE output SEPARATOR "|" WIDTH UNLIMITED
AT LEFT FIELD separator "", 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED.



header
using output 
"projectiid",
"uprojectid",
"projectname",
"m.muname",
"m2.muname",
"m.nationalmusym",
"liid",
"a.areasymbol",
"musym",
"mukey",
"mustatus",
"lm.muacres",
"dmudesc".
End Header.

SECTION
DATA
USING output 
projectiid,
uprojectid,
projectname,
m.muname,
m2.muname,
m.nationalmusym,
liid,
a.areasymbol,
lm.musym,
mukey,
mustatus,
lm.muacres,
dmudesc.
End section.
```

```{r, }
# This email is for my documentation and I chose to send it for your information.  Do with it what you wish.
# 
# There has been a natural progression of Division initiatives - first, RaCA allowing folks to see remote areas of the MLRA and sample soils within the MLRA; then SDJR allowing folks to take ownership of their MLRA to evaluate map units and harmonize data.  Time will come to begin using the harmonized SDJR information to document the MLRA.  Several of us are working on the latter.  Having some preliminary analysis, I thought I would share with you some findings.  As you are aware, geology (parent material) and physiography are two of the seven MLRA criteria, and after 4 years of SDJR, these properties should be clean enough to be mined from the Soil Data Mart.  To assist this MLRA project, I was asked to write an SDA query to mine the parent material, the landform, and the restrictions.  Feel free to modify and use the sql to map your areas.

--start sql
SELECT areasymbol, musym, m.mukey, c.cokey, compname, comppct_r
, case when charindex(' ', pmgroupname, charindex(' ', pmgroupname) - 1) = 0
then pmgroupname else left(pmgroupname, charindex(' ', pmgroupname, charindex(' ', pmgroupname) - 1)) end AS pm
, pmgroupname, copmkey, pmorder, pmmodifier, pmgenmod, pmkind, pmorigin
, (SELECT TOP 1 cogeomordesc.geomfname FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Landform') as landform
, (SELECT TOP 1  resdept_r  from corestrictions WHERE c.cokey = corestrictions.cokey and reskind is not null) as restrictiondepth
, (SELECT TOP 1 reskind from corestrictions WHERE c.cokey = corestrictions.cokey and reskind is not null) as restrictionkind
, ROW_NUMBER() Over(Partition by m.mukey order by l.areasymbol, m.mukey, c.comppct_r DESC, pmorder) as RowNum 
INTO #PM_LAND 
FROM legend l
inner join mapunit m on l.lkey=m.lkey and l.areasymbol <> 'US'
inner join component c on m.mukey=c.mukey AND c.cokey = (SELECT TOP 1 component.cokey FROM component WHERE component.mukey=m.mukey ORDER BY component.comppct_r DESC)
left outer join copmgrp on c.cokey = copmgrp.cokey AND copmgrp.rvindicator='yes'
left outer join copm on copmgrp.copmgrpkey=copm.copmgrpkey
order by areasymbol, musym, comppct_r desc, pmorder

SELECT areasymbol, musym, mukey, cokey, compname, comppct_r, pm, case when pmorigin is null then pmkind when pmkind is null then pmorigin else pmorigin +' '+pmkind end as parentmaterial
, pmgroupname, landform, restrictionkind, pmorder, pmmodifier, pmgenmod, pmkind, pmorigin, restrictiondepth, RowNum
FROM #PM_LAND
WHERE RowNum = (SELECT TOP 1 RowNum FROM #PM_LAND pl WHERE pl.mukey=#PM_LAND.mukey ORDER BY RowNum desc)
ORDER BY areasymbol, musym, pmorder desc
--end sql

# The sql pulls the dominant component information.  
# The 'pm' column is extracted from the first word in the pm group name column (typically surface pm).  
# The 'parentmaterial'  column is extracted as a concatenation of the PM origin and PM Kind from the lowest level data recorded in the component parent material table, assuming closest to the geological processes.   
# The 'pmgroupname' comes from what you populated in the copmgrp table
# The 'landform' comes from the first landform instance you populated.  
# The 'restrictionkind' column is the first instance of a restriction you populated.
# The pmkind and pmorigin are those entries with the highest row count based on the sql (lowest level).  This could have been pulled using pmorder, however inconsistent population of the field necessitated a different method of extraction.
# The intent of restricting the PM column to the first word and the 'parentmaterial' column to the lowest set of information is to reduce the amount of information and thereby improving the ability to map the features.  
# 
# You can change the l.areasymbol <> 'US' to read l.areasymbol like 'ID%' to retrieve a specific state worth of data.  Remember, this is using the 2015 SDM data and does not include the vast amount of work that has been completed this fiscal year.
# 
# The first sql extracts the data.  
# 
# The second sql transforms the data needed for mapping:  Notice on the map unit 388, the surface pm would be 'colluvium' and the 'geology' parentmaterial would be Limestone Residuum.  

```

```{r select major}
SELECT * 
  
FROM component c1

WHERE comppct_r = (SELECT MAX(comppct_r) FROM component AS c2 WHERE mukey = '170705'  AND c1.mukey = c2.mukey GROUP BY mukey)


library(plyr)

# Set working directory
setwd("C:/workspace")

# read in component text file
component <- read.csv("component.csv")

# ddply
component_max <- ddply(component, .(mukey), function(x) x[which.max(x$comppct_r), ])

# or
component_max <- do.call("rbind", by(component, list(component$mukey), function(x) x[which.max(x$comppct_r), ]))

# save output
write.csv(component_max, file = "component_max.csv")
```