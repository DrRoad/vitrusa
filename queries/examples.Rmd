```{r NASIS query and report inventory}

get_sdjr_NASIS_db <- function(selected_set = TRUE) {
  # must have RODBC installed
  if(!requireNamespace('RODBC'))
    stop('please install the `RODBC` package', call.=FALSE)
  
  q <- paste("SELECT p.uprojectid, p.projectname, a2.areasymbol, lmu.lmapunitiid AS mukey, lmu.musym, mu.nationalmusym, muname, muacres
  
  FROM",
  if (selected_set != TRUE) {"project p INNER JOIN"
    } else "project_View_1 p INNER JOIN",
      "projectmapunit pmu ON pmu.projectiidref = p.projectiid INNER JOIN 
      mapunit mu ON mu.muiid = pmu.muiidref INNER JOIN
      lmapunit lmu ON lmu.muiidref = mu.muiid INNER JOIN
      legend l ON l.liid = lmu.liidref
  INNER JOIN 
      area a ON a.areaiid = p.mlrassoareaiidref
  INNER JOIN
      area a2 ON a2.areaiid = l.areaiidref

  WHERE 
      a.areasymbol LIKE '11-%' AND 
      p.uprojectid LIKE '%' AND 
      p.projectapprovedflag = 1 AND
      (l.legendsuituse != 1 OR l.legendsuituse IS NULL)

  ORDER BY p.projectname, a.areasymbol;"
  )
  
  # setup connection local NASIS
  channel <- RODBC::odbcDriverConnect(connection="DSN=nasis_local;UID=NasisSqlRO;PWD=nasisRe@d0n1y")
  
  # exec query
  d <- RODBC::sqlQuery(channel, q, stringsAsFactors=FALSE)

  # close connection
  RODBC::odbcClose(channel)
  
  # done
  return(d)
}


get_reports_NASIS_db <- function() {
  # must have RODBC installed
  if(!requireNamespace('RODBC'))
    stop('please install the `RODBC` package', call.=FALSE)
  
  q <- "SELECT rptiid, rptname, grpname, nasissitename
  
  FROM report
  
  INNER JOIN nasisgroup ng ON ng.grpiid = report.grpiidref
  INNER JOIN nasissite ns ON ns.nasissiteiid = ng.nasissiteiidref;"
  
  # setup connection local NASIS
  channel <- RODBC::odbcDriverConnect(connection="DSN=nasis_local;UID=NasisSqlRO;PWD=nasisRe@d0n1y")
  
  # exec query
  d <- RODBC::sqlQuery(channel, q, stringsAsFactors=FALSE)
  
  # close connection
  RODBC::odbcClose(channel)
  
  # done
  return(d)
}

```

```{r Steve Campbell examples}
# Report to select the dominant component by mapunit

PARAMETER asymbol CHARACTER PROMPT "area_symbol (e.g IN001 or IN%)" REQUIRED.

EXEC SQL 
SELECT area.areasymbol, lmu.lmapunitiid/1 mukey, mu.muname, co.compname, co.comppct_r

FROM 
component co INNER JOIN
datamapunit dmu ON dmu.dmuiid = co.dmuiidref INNER JOIN
correlation cor ON cor.dmuiidref = dmu.dmuiid INNER JOIN
mapunit mu ON mu.muiid = cor.muiidref INNER JOIN
lmapunit lmu ON lmu.muiidref = mu.muiid INNER JOIN
legend l ON l.liid = lmu.liidref INNER JOIN
area ON area.areaiid = l.areaiidref

WHERE 
co.majcompflag = 1 AND 
area.areasymbol LIKE asymbol AND 
cor.repdmu = 1 AND 
l.legendsuituse != 1;

SORT BY area.areasymbol, mu.muname, co.comppct_r DESC
AGGREGATE COLUMN co.comppct_r FIRST.


# Dom Component NASIS report. The yellow highlighted area is the dominant component part of the script. 

PARAMETER area2 ELEMENT area.areasymbol PROMPT 'Survey Symbol for wildcards use % '.

BASE TABLE component.

EXEC SQL
SELECT DISTINCT areasymbol, lmapunitiid/1 AS mukey, musym, dmuiid, muiid, muname, farmlndcl, coiid/1 AS coiid, component.compname AS tc, comppct_r, majcompflag 
FROM REAL area_type
INNER JOIN        REAL area BY default AND areasymbol LIKE area2 AND areatypename = 'non-mlra soil survey area'
INNER JOIN        REAL legend BY default AND legendsuituse = 'current wherever mapped'
INNER JOIN        REAL lmapunit BY default
INNER JOIN  REAL mapunit BY default AND mustatus = 'correlated'
INNER JOIN  REAL correlation BY default
INNER JOIN  REAL datamapunit BY default AND repdmu = 1
INNER JOIN  REAL component BY default 
AND component.coiid =
(SELECT TOP 1 c1.coiid FROM component AS c1 
INNER JOIN datamapunit AS d1 ON  d1.dmuiid=c1.dmuiidref
INNER JOIN correlation AS cor1 ON cor1.dmuiidref=d1.dmuiid AND repdmu =1
INNER JOIN mapunit AS c ON c.muiid=cor1.muiidref AND c.muiid=mapunit.muiid ORDER BY c1.comppct_r DESC, c1.coiid);.

# component_wtavg_pH_SDA_query - This query calculates the weighted average pH in the 0-50 cm depth range for major components
-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r INTO #table1

FROM legend

INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey 
-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r
-- Calculate horizon thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2
FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate pH multiplied by horizon thickness

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4
FROM #table3

GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate weighted average pH for components

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC



# component_wtavg_pH_SDA_query - This query calculates the weighted average pH in the 0-50 cm depth range for major components

-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r

INTO #table1

FROM legend

INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey 
-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r
-- Calculate horizon thicknesses


SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2


FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate pH multiplied by horizon thickness


SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r
-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4

FROM #table3
GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r
ORDER BY areasymbol, musym, comppct_r DESC
-- Calculate weighted average pH for components

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC



# sda_sql_query_for_taxonomy - SDA SQL query for taxonomy- Note will not get result for consociations of miscellaneous areas such as water -Rob Vaughan with help from Steve Campbell 

SELECT
legend.areasymbol, legend.lkey, mapunit.muname, mapunit.mukey, component.cokey, component.comppct_r, component.compname, component.compkind, component.taxclname, component.taxorder, component.taxsuborder, component.taxgrtgroup, component.taxsubgrp, component.taxpartsize, component.taxpartsizemod, component.taxtempcl, component.taxmoistscl, component.taxtempregime, component.soiltaxedition

FROM legend
INNER JOIN mapunit ON legend.lkey = mapunit.lkey  
LEFT OUTER JOIN component ON mapunit.mukey = component.mukey  
  
WHERE legend.areasymbol LIKE 'WY043%' AND 
component.cokey = (SELECT TOP 1 component.cokey FROM component.mukey = mapunit.mukey AND component.taxorder is not null ORDER BY component.comppct_r DESC)
ORDER BY component.comppct_r DESC)

ORDER BY legend.areasymbol, legend.lkey, mapunit.mukey, component.cokey



# mapunit_wtavg_pH_SDA_query -- This query calculates the weighted average pH in the 0-50 cm depth range for major components aggregated to the mapunit.

-- Calculate horizon bottom depth as 50 for horizons that span the 50 cm depth.

SELECT legend.areasymbol, legend.areaname, mapunit.musym, mapunit.muname, mapunit.mukey, component.cokey, component.compname, component.comppct_r, chorizon.hzdept_r, case when hzdepb_r > 50 then 50 else hzdepb_r end AS bot_depth, chorizon.ph1to1h2o_r

INTO #table1

FROM legend
INNER JOIN mapunit on legend.lkey = mapunit.lkey
INNER JOIN component ON mapunit.mukey = component.mukey
INNER JOIN chorizon on component.cokey = chorizon.cokey

-- Modify the areasymbol criteria to run for any soil survey area.  Use LIKE 'OR%' to
-- run for entire State.  Remove completely to run for entire Soil Data Mart database.

WHERE chorizon.hzdept_r <50 AND chorizon.ph1to1h2o_r Is Not Null AND component.majcompflag = 'yes' AND legend.areasymbol = 'OR620'

ORDER BY legend.areasymbol, mapunit.musym, component.comppct_r DESC , chorizon.hzdept_r

-- Calculate horizon thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, bot_depth- hzdept_r AS hz_thickness

INTO #table2
FROM #table1

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r

-- Calculate pH multiplied by horizon thickness

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, hzdept_r, bot_depth, ph1to1h2o_r, hz_thickness, ph1to1h2o_r * hz_thickness AS pH_x_thickness

INTO #table3
FROM #table2

ORDER BY areasymbol, musym, comppct_r DESC , hzdept_r

-- Calculate sums of horizon thicknesses and sums of pH x thicknesses

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, sum(hz_thickness) AS sum_thickness,  sum(pH_x_thickness) AS sum_pH_x_thickness

INTO #table4
FROM #table3

GROUP BY areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate weighted average pH for component

SELECT areasymbol, areaname, musym, muname, mukey, cokey, compname, comppct_r, CAST(sum_pH_x_thickness / sum_thickness AS Decimal(4,1)) AS pH_wtavg_0_50

INTO #table5
FROM #table4

ORDER BY areasymbol, musym, comppct_r DESC

-- Calculate sums to use in mapunit weighted average pH calculation.

SELECT areasymbol, areaname, musym, muname, mukey, sum(comppct_r) AS sum_comppct, sum(comppct_r * pH_wtavg_0_50) AS sum_comppct_x_pH

INTO #table6
FROM #table5

GROUP BY areasymbol, areaname, musym, muname, mukey

ORDER BY areasymbol, musym

-- Calculate mapunit weighted average pH

SELECT areasymbol, areaname, musym, muname, mukey, CAST(sum_comppct_x_pH / sum_comppct AS Decimal(4,1)) AS pH_wtavg_0_50_mu

FROM #table6

ORDER BY areasymbol, musym
```

```{r correlation example}
EXEC SQL SELECT
projectiid/1 AS projectiid,
uprojectid,
projectname,
m.muname,
m2.muname,
m.nationalmusym,
l.liid/1 AS liid,
a.areasymbol,
lm.musym,
lm.lmapunitiid/1 as mukey,
CODELABEL(lm.mustatus) as mustatus,
lm.muacres,
dmudesc

FROM project AS p
INNER JOIN REAL projectmapunit AS pm ON pm.projectiidref = p.projectiid
INNER JOIN REAL mapunit AS m ON m.muiid = pm.muiidref
INNER JOIN REAL correlation AS c ON c.muiidref = m.muiid
INNER JOIN REAL datamapunit AS dm ON dm.dmuiid = c.dmuiidref
INNER JOIN REAL correlation AS c2 on c2.dmuiidref = dm.dmuiid
INNER JOIN REAL mapunit AS m2 on m2.muiid = c2.muiidref

INNER JOIN REAL lmapunit AS lm ON lm.muiidref = m.muiid
INNER JOIN REAL legend AS l ON l.liid = lm.liidref
INNER JOIN REAL area AS a ON a.areaiid = l.areaiidref;.

PAGE WIDTH UNLIMITED LENGTH UNLIMITED.

TEMPLATE output SEPARATOR "|" WIDTH UNLIMITED
AT LEFT FIELD separator "", 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, 
FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED, FIELD WIDTH UNLIMITED.



header
using output 
"projectiid",
"uprojectid",
"projectname",
"m.muname",
"m2.muname",
"m.nationalmusym",
"liid",
"a.areasymbol",
"musym",
"mukey",
"mustatus",
"lm.muacres",
"dmudesc".
End Header.

SECTION
DATA
USING output 
projectiid,
uprojectid,
projectname,
m.muname,
m2.muname,
m.nationalmusym,
liid,
a.areasymbol,
lm.musym,
mukey,
mustatus,
lm.muacres,
dmudesc.
End section.
```

```{r, }
# This email is for my documentation and I chose to send it for your information.  Do with it what you wish.
# 
# There has been a natural progression of Division initiatives - first, RaCA allowing folks to see remote areas of the MLRA and sample soils within the MLRA; then SDJR allowing folks to take ownership of their MLRA to evaluate map units and harmonize data.  Time will come to begin using the harmonized SDJR information to document the MLRA.  Several of us are working on the latter.  Having some preliminary analysis, I thought I would share with you some findings.  As you are aware, geology (parent material) and physiography are two of the seven MLRA criteria, and after 4 years of SDJR, these properties should be clean enough to be mined from the Soil Data Mart.  To assist this MLRA project, I was asked to write an SDA query to mine the parent material, the landform, and the restrictions.  Feel free to modify and use the sql to map your areas.

--start sql
SELECT areasymbol, musym, m.mukey, c.cokey, compname, comppct_r
, case when charindex(' ', pmgroupname, charindex(' ', pmgroupname) - 1) = 0
then pmgroupname else left(pmgroupname, charindex(' ', pmgroupname, charindex(' ', pmgroupname) - 1)) end AS pm
, pmgroupname, copmkey, pmorder, pmmodifier, pmgenmod, pmkind, pmorigin
, (SELECT TOP 1 cogeomordesc.geomfname FROM cogeomordesc WHERE c.cokey = cogeomordesc.cokey AND cogeomordesc.rvindicator='yes' and cogeomordesc.geomftname = 'Landform') as landform
, (SELECT TOP 1  resdept_r  from corestrictions WHERE c.cokey = corestrictions.cokey and reskind is not null) as restrictiondepth
, (SELECT TOP 1 reskind from corestrictions WHERE c.cokey = corestrictions.cokey and reskind is not null) as restrictionkind
, ROW_NUMBER() Over(Partition by m.mukey order by l.areasymbol, m.mukey, c.comppct_r DESC, pmorder) as RowNum 
INTO #PM_LAND 
FROM legend l
inner join mapunit m on l.lkey=m.lkey and l.areasymbol <> 'US'
inner join component c on m.mukey=c.mukey AND c.cokey = (SELECT TOP 1 component.cokey FROM component WHERE component.mukey=m.mukey ORDER BY component.comppct_r DESC)
left outer join copmgrp on c.cokey = copmgrp.cokey AND copmgrp.rvindicator='yes'
left outer join copm on copmgrp.copmgrpkey=copm.copmgrpkey
order by areasymbol, musym, comppct_r desc, pmorder

SELECT areasymbol, musym, mukey, cokey, compname, comppct_r, pm, case when pmorigin is null then pmkind when pmkind is null then pmorigin else pmorigin +' '+pmkind end as parentmaterial
, pmgroupname, landform, restrictionkind, pmorder, pmmodifier, pmgenmod, pmkind, pmorigin, restrictiondepth, RowNum
FROM #PM_LAND
WHERE RowNum = (SELECT TOP 1 RowNum FROM #PM_LAND pl WHERE pl.mukey=#PM_LAND.mukey ORDER BY RowNum desc)
ORDER BY areasymbol, musym, pmorder desc
--end sql

# The sql pulls the dominant component information.  
# The 'pm' column is extracted from the first word in the pm group name column (typically surface pm).  
# The 'parentmaterial'  column is extracted as a concatenation of the PM origin and PM Kind from the lowest level data recorded in the component parent material table, assuming closest to the geological processes.   
# The 'pmgroupname' comes from what you populated in the copmgrp table
# The 'landform' comes from the first landform instance you populated.  
# The 'restrictionkind' column is the first instance of a restriction you populated.
# The pmkind and pmorigin are those entries with the highest row count based on the sql (lowest level).  This could have been pulled using pmorder, however inconsistent population of the field necessitated a different method of extraction.
# The intent of restricting the PM column to the first word and the 'parentmaterial' column to the lowest set of information is to reduce the amount of information and thereby improving the ability to map the features.  
# 
# You can change the l.areasymbol <> 'US' to read l.areasymbol like 'ID%' to retrieve a specific state worth of data.  Remember, this is using the 2015 SDM data and does not include the vast amount of work that has been completed this fiscal year.
# 
# The first sql extracts the data.  
# 
# The second sql transforms the data needed for mapping:  Notice on the map unit 388, the surface pm would be 'colluvium' and the 'geology' parentmaterial would be Limestone Residuum.  

```

```{r select major}
SELECT * 
  
FROM component c1

WHERE comppct_r = (SELECT MAX(comppct_r) FROM component AS c2 WHERE mukey = '170705'  AND c1.mukey = c2.mukey GROUP BY mukey)


library(plyr)

# Set working directory
setwd("C:/workspace")

# read in component text file
component <- read.csv("component.csv")

# ddply
component_max <- ddply(component, .(mukey), function(x) x[which.max(x$comppct_r), ])

# or
component_max <- do.call("rbind", by(component, list(component$mukey), function(x) x[which.max(x$comppct_r), ]))

# save output
write.csv(component_max, file = "component_max.csv")
```

```{WEB-spatial_asym_uprojectid_dates}
# Stephen Roecker & Jason Nemecek
# Old version was WEB-Correlation_state_fy
# Improves on the old version because it doesn't require the projects to be correlated before they show up.


PARAMETER asymbol CHARACTER PROMPT "area_symbol (e.g IN001 or IN%)" REQUIRED.
PARAMETER project_id CHARACTER PROMPT 'user project id (e.g. 201611IND001 or 2016%)' REQUIRED.
PARAMETER start_date CHARACTER PROMPT 'start_date (e.g. 10/01/2015)' REQUIRED.
PARAMETER finish_date CHARACTER PROMPT 'finish_date (e.g. 10/01/2016)' REQUIRED.


EXEC SQL SELECT DISTINCT 
pmg.fiscalyear/1 fy, REPLACE(SUBSTRING(mlra.areasymbol, 1, 2), '-', '') region, mlra.areasymbol office, 
projecttypename, p.projectiid/1 projectiid, p.uprojectid, p.projectname, a.areasymbol, lmu.musym, lmu.lmapunitiid/1 mukey,
mu.nationalmusym, CODELABEL(mu.mutype) mutype, mu.muname, lmu.muacres/1 muacres,
lmu_new.musym new_musym, lmu_new.lmapunitiid/1 new_mukey, mu_new.nationalmusym new_nationalmusym, CODELABEL(mu_new.mutype) new_mutype, mu_new.muname new_muname,
lmu_new.muacres/1 new_muacres,
CASE WHEN pmu.seqnum = YEAR('10/01/2016') OR # flagged in the project map unit table
    lmu.muacres != lmu_new.muacres OR # split in the legend
    (lmu.musym != lmu_new.musym AND # MUSYM change
    (lmu.musym LIKE '[zx]%' OR lmu.musym LIKE '%[ZS]' OR lmu.musym LIKE '%[zx]' OR lmu.musym LIKE '%[Z]' OR # Region 11 rules for legend constraint error
    lmu.musym LIKE '[a]%' OR lmu.musym LIKE '%[a]' OR lmu.musym LIKE '%[+]' OR lmu.musym LIKE '%[_old]')) OR # Other Region rules for legend constraint error
    (SELECT COUNT(lmu2.lmapunitiid)
    FROM  
        project p2 INNER JOIN
        projectmapunit pmu2 ON pmu2.projectiidref = p2.projectiid INNER JOIN
        mapunit mu2 ON mu2.muiid = pmu2.muiidref INNER JOIN
        lmapunit lmu2 ON lmu2.muiidref = mu2.muiid INNER JOIN 
        legend l2 ON l2.liid = lmu2.liidref INNER JOIN
        area a2 ON a2.areaiid = l2.areaiidref
    WHERE l2.liid = l.liid AND p2.projectiid = p.projectiid AND a2.areaiid = a.areaiid AND
        (mu2.mutype = 2 OR mu2.mutype IS NULL)) > 1
    THEN 'TRUE' ELSE 'FALSE' END spatial_change, # CASE rules to detect a spatial change
CASE WHEN lmu_new.lmapunitiid IS NULL THEN lmu.lmapunitiid ELSE lmu_new.lmapunitiid END current_mukey

            
FROM 
    project p INNER JOIN  
    projectmapunit pmu ON pmu.projectiidref = p.projectiid INNER JOIN 
    projectmilestone pm ON pm.projectiidref = p.projectiid

    LEFT OUTER JOIN  
        projectmappinggoal pmg ON pmg.projectiidref = p.projectiid 

    INNER JOIN  
        mapunit mu ON mu.muiid = pmu.muiidref INNER JOIN  
        lmapunit lmu ON lmu.muiidref = mu.muiid INNER JOIN  
        legend l ON l.liid = lmu.liidref LEFT OUTER JOIN  
        area a ON a.areaiid = l.areaiidref AND a.areasymbol LIKE asymbol INNER JOIN
        areatype at ON at.areatypeiid = a.areatypeiidref
             
        INNER JOIN  
            correlation cor ON cor.muiidref = mu.muiid AND cor.repdmu = 1
             
    INNER JOIN  
        area mlra ON mlra.areaiid = p.mlrassoareaiidref LEFT OUTER JOIN 
        projecttype pt ON pt.projecttypeiid = p.projecttypeiidref INNER JOIN 
        milestonetype mt ON mt.milestonetypeiid = pm.milestonetypeiidref 
              
    LEFT OUTER JOIN
        (project p_new INNER JOIN
        projectmapunit pmu_new ON pmu_new.projectiidref = p_new.projectiid INNER JOIN 
        mapunit mu_new ON mu_new.muiid = pmu_new.muiidref AND mu_new.mutype = 1 LEFT OUTER JOIN
        lmapunit lmu_new ON lmu_new.muiidref = mu_new.muiid AND lmu_new.mustatus != "additional"
        
        INNER JOIN
            correlation cor_new ON cor_new.muiidref = mu_new.muiid AND cor_new.repdmu != 1) 
            ON p_new.projectiid = p.projectiid
            AND cor_new.dmuiidref = cor.dmuiidref AND lmu_new.liidref = lmu.liidref

WHERE 
    (pm.seqnum = YEAR(start_date) OR mu.mutype != 1 OR mu.mutype IS NULL) AND
    p.uprojectid LIKE project_id AND # projectid matches
    ((milestonetypename LIKE '%Correlation activities%' AND 
    pm.scheduledcompletiondate BETWEEN start_date AND finish_date) OR pmg.fiscalyear = YEAR(finish_date)) AND # project falls within the timeframe
    p.projectapprovedflag = 1 AND # project is approved
    legendsuituse != 1 AND at.areatypename = 'non-mlra soil survey area'
             
ORDER BY mlra.areasymbol, p.projectname, a.areasymbol, lmu.musym;.


TEMPLATE basic TAG "td" ELEMENT "tr" 
FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD,
FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD, FIELD,
FIELD, FIELD.

SECTION WHEN AT START  #sets the report name and initial header
DATA
ELEMENT OPEN "section" ATTRIB ("label", "SoilReport").    #opens section
ELEMENT OPEN "table".                                                #opens table
ELEMENT OPEN "thead".                                #Opens table header
USING basic     
"fy", 
"region",
"office",
"projecttypename", 
"projectiid",
"uprojectid", 
"projectname",
"areasymbol", 
"musym",
"mukey", 
"nationalmusym",
"muname",
"mutype",
"muacres",
"new_musym",
"new_mukey",
"new_nationalmusym",
"new_mutype",
"new_muname", 
"new_muacres", 
"spatial_change",
"current_mukey".

ELEMENT CLOSE "thead".                               #Closes table header
ELEMENT OPEN "tbody".                                #opens table body
END SECTION.

SECTION     #adds the data to the report
DATA
USING basic 
fy, 
region,
office,
projecttypename, 
projectiid,
p.uprojectid, 
p.projectname,
a.areasymbol, 
lmu.musym,
mukey, 
mu.nationalmusym,
mu.muname,
mutype,
muacres,
new_musym,
new_mukey,
new_nationalmusym,
new_mutype,
new_muname, 
new_muacres, 
spatial_change,
current_mukey.   
END SECTION.

SECTION when at end   #closes the report
DATA
ELEMENT CLOSE "tbody".                              #Closes table body
ELEMENT CLOSE "table".                               #closes table
ELEMENT CLOSE "section".                           #closes section
END SECTION.
```