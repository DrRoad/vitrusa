
# Map Unit Spatial Summary Report

This report summarizes the geographic setting of a list of musym within a shapefile. It is intented to be used to compare and contrast map units, and suggest possible Low, RV, and High values for soil components. 

```{r load-data, echo=FALSE, results='hide', message=FALSE}
shp <- "M:/geodata/project_data/11IND/cache/201611IND044_Fxsltlm,0t2prcntslps_QA.shp"

geodatabase <- "M:/geodata/project_data/11IND/RTSD_R11-IND_FY16.gdb"

# Defaults
samplePercent <- 15
p <- c(0, 0.25, 0.5, 0.75, 1)

dir <- "M:/geodata/project_data/"
office <- "11IND"
```


```{r LoadPackages, include=FALSE}
library(knitr)
library(lattice)
library(latticeExtra)
library(circular)
library(maps)
library(maptools)
library(sp)
library(raster)
library(rgdal)
library(rgeos)
library(plyr)
library(reshape2)

source("../soilDB_x/utils.R")

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
options(stringsAsFactors = FALSE)

opar <- trellis.par.get()
trellis.par.set(theme = ggplot2like())
tpg <- trellis.par.get()
tpg$axis.line <-  list(alpha = 1, col = "#000000", lty = rep(1, 7), lwd = rep(0.2, 7))
tpg$strip.border <- list(alpha = 1, col = "#000000", lty = rep(1, 7), lwd = rep(0.2, 7))
trellis.par.set(tpg)
```

```{r map unit summary function}

office_folder <- paste0(dir, office, "/")
region_folder <- paste0(dir, "11REGION/")
cache <- paste0(shp, "_", samplePercent, ".Rdata")

## local functions
if (!file.exists(cache)){
  layer <- {sub(".shp", "", shp) ->.;
    strsplit(., "/")[[1]] ->.;
    .[length(.)]}
  
  sapolygon <- readOGR(dsn = geodatabase, layer = "SAPOLYGON", encoding = "OpenFileGDB")
  mupolygon <- readOGR(dsn = shp, layer = layer, encoding = "ESRI Shapefile")
  
  names(mupolygon) <- tolower(names(mupolygon))
  
  mupolygon@data <- transform(mupolygon,
                              Acres = mupolygon@data[, grepl("_area", names(mupolygon))] * 0.000247105,
                              Circularity = mupolygon@data[, grepl("_leng", names(mupolygon))] / 
                                (2 * sqrt(mupolygon@data[, grepl("_area", names(mupolygon))] / pi) * pi)
                              )
  n <- ceiling(sum(mupolygon@data[, grepl("_area", names(mupolygon))]) / 900 * samplePercent / 100)
  
  # Sample soil map unit
  mupolygon.s <- {sapply(slot(mupolygon, 'polygons'), function(x) as.data.frame(spsample(x,
                                     n = ceiling(x@area / 900 * samplePercent / 100),
                                     type = "random"))
               ) ->.; do.call("rbind", .)}
  coordinates(mupolygon.s) <- ~ x + y
  proj4string(mupolygon.s) <- proj4string(mupolygon)
  # mupolygon.s <- spsample(mupolygon, n = n, "stratified") # this is incredibly slow
  geodata <- raster_extract(mupolygon.s)
  mapunit.df <- over(mupolygon.s, mupolygon)
  
  names(mapunit.df) <- tolower(names(mapunit.df))
  names(geodata) <- tolower(names(geodata))
  
  data <- cbind(mapunit.df[c("areasymbol", "musym")], geodata)
  
#  mlra <- readOGR(dsn = "M:/geodata/project_data/11REGION/mlra_a_r11.shp", layer = "mlra_a_r11", encoding = "ESRI Shapefile")
#  mlra_i <- over(mupolygon.s, mlra)
#  mlra_acres <- ddply(mlra_i, .(MLRARSYM), summarize, mlra_percent = sum(length(OBJECTID)))
#  mlra_acres <- transform(mlra_acres, mlra_percent = round(mlra_percent / sum(mlra_percent) * 100, 0))

  data.l <- list(data = data, mupolygon = mupolygon, sapolygon = sapolygon)
  save(data.l, file = cache)
} else load(file = cache) #load cache file


attach(data.l)
# mlra_acres <- data.l$mlra_acres

data$ssa_musym <- with(data, paste(areasymbol, musym))
data2 <- data
data2$ssa_musym <- "*mlra_mapnit"
data <- rbind(data2, data)
```


### Shapefile Name
```{r project name}
shp
```


### Variables

```{r variables}
a <- c("elev", "slope", "aspect", "valley", "wetness", "relief", "ppt", "temp", "ffp", "lulc")
m <- c("elevation", "slope gradient", "slope aspect", "multiresolution valley bottom index", "topographic Wetness index", "height above channel", "annual precipitation", "annual air temperature", "frost free period", "land use and land cover")
u <- c("meters", "percent", "degrees", "unitless", "unitless", "meters", "millimeters", "degrees Celsius", "days", "landcover class (e.g. Wood Wetlands)")
s <- c("30-meter USGS National Elevation Dataset (NED)", "10-meter NED", "10-meter NED", "30-meter NED", "30-meter NED", "30-meter NED", "800-meter 30-year normals (1981-2010) from PRISM Climate Dataset", "800-meter 30-year normals (1981-2010) from PRISM Climate Dataset", "1000-meter 30-year normals (1961-1990) from USFS RMRS", "2011 National Land Cover Dataset (NLCD)")

variables <- data.frame(Abbreviation = a, Measures = m, Unit = u, Source = s)

kable(variables)
```


## Map of soil polygons

```{r plot soil map units}
st <- map("state", plot = FALSE)
st_sp <- {map2SpatialLines(st, proj4string = CRS("+init=epsg:4326")) ->.;
  spTransform(., CRS("+init=epsg:5070"))
  }

plot(mupolygon, axes = TRUE)
plot(sapolygon, add = TRUE)
plot(st_sp,lwd=3, add = TRUE)
```

## Soil polygon metrics
Five number summary (min, 25th, median, 75th, max)(percentiles) and contingency table (counts)(n) 
Circularity is an estimate of SHAPE complexity (Hole and Campbell, 1975), computed as a ratio of mupolygon length / mupolygon circumference. The SHAPE complexity of a perfect circle would equal 1.

```{r soil polygon metrics, results='asis', fig.width=8}
pol <- data.frame(mupolygon)
pol$ssa_musym <- as.character(paste(pol$areasymbol, pol$musym))
pol2 <- pol
pol2$ssa_musym <- "*mlra_mapnit"
pol <- rbind(pol2, pol)

pol.lo1 <- melt(pol, id.vars="ssa_musym", measure.vars=c("Acres", "Circularity"))
pol.lo2 <- melt(pol, id.vars="ssa_musym", measure.vars=c("Acres"))
pol.5n1 <- ddply(pol.lo2, .(ssa_musym, variable), .fun=sum5n2)
pol.5n2 <- ddply(pol, .(ssa_musym), summarize, 
                 nArces=round(sum(Acres), 0), 
                 nPolygons=length(musym))
pol.5n <- join(pol.5n1, pol.5n2, by = "ssa_musym")

kable(pol.5n, digits = 0, align = "c", caption = "Summary of musym by areasymbol")

# kable(mlra_acres, digits = 0, align = "c", caption = "Summary of Acres by MLRA")

# pol.lo1$ssa_musym <- as.factor(pol.lo1$ssa_musym)
pol.lo1$ssa_musym <- factor(pol.lo1$ssa_musym, 
                            levels = rev(sort(unique(pol.lo1$ssa_musym)))
                            )
                                                          
bwplot(ssa_musym ~ value | variable, 
       data = pol.lo1, 
       scales = list(x="free"), main = "Boxplots of polygon metrics", 
       as.table = TRUE
       )
```

## Contingency tables (percent) 

```{r percentage by musym, results='asis'}
## Create descriptive and graphical summary of map unit
kable(prop.table(xtabs(~ ssa_musym + slope_classes, data = data, drop.unused.levels = TRUE), 
                 margin = 1) * 100, 
      align = "c", digits=0, caption="Slope classes")
kable(prop.table(xtabs(~ ssa_musym + aspect_classes, data = data, drop.unused.levels = TRUE), 
                 margin = 1) * 100, 
      align = "c", digits = 0, caption = "Aspect classes")
kable(prop.table(xtabs(~ ssa_musym + valley_classes, data = data, drop.unused.levels = TRUE),
                 margin = 1) * 100, 
      align = "c", digits = 0, caption = "Upland vs. lowland")

lulc_t <- {xtabs(~ ssa_musym + lulc_classes, data = data, drop.unused.levels = TRUE) ->.;
  addmargins(prop.table(., margin = 1)) * 100}
idx <- pindex(lulc_t, 8)
for (i in unique(idx)){
  print(kable(lulc_t[, c(idx == i)], digits = 0, align = "c", caption = "Landuse and Landcover"))
  }
```

## Quantile breaks
Five number summary (min, 25th, median, 75th, max)(percentiles) and number of random samples (n)

```{r quantiles by musym, results="asis", warning=FALSE, fig.height=10, fig.width=8}
data.lo <- melt(data, id.vars="ssa_musym", measure.vars = c("elev", "slope", "valley", "wetness", "relief", "ppt", "temp", "ffp"))

data.5n <- ddply(data.lo, .(variable, ssa_musym), .fun = sum5n2)


data.c <- dcast(data.5n, ssa_musym ~ variable, value.var = 'range')
data.n <- ddply(data, .(ssa_musym), .drop=T, summarize, n = length(ssa_musym))

aspect.lo <- melt(data, id.vars="ssa_musym", measure.vars = c("aspect"))
aspect.lo$value <- circular(aspect.lo$value, template = "geographic", units="degrees", modulo="2pi")
aspect.5n <- ddply(aspect.lo, .(variable, ssa_musym), .fun = sum5n2)
aspect.c <- dcast(aspect.5n, ssa_musym ~ variable, value.var = 'range')

kable(cbind(data.c[c(1:6)], data.n["n"]), align = "c")
kable(cbind(data.c[c(1, 7:9)], aspect.c["aspect"], data.n["n"]), align = "c")

data.lo$ssa_musym <- factor(data.lo$ssa_musym, 
                            levels = rev(sort(unique(data.lo$ssa_musym)))
                            )

bwplot(ssa_musym ~ value | variable, 
       data = data.lo, 
       scales=list(x="free"), main = "Boxplots of map unit properties", 
       as.table = TRUE, layout = c(2, 4)
       )
```
